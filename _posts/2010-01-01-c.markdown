---
layout: chapter
title: The Ruby C API
---

## 开始之前 ##

如果你想完整看完这篇 guide，我建议你需要不抗拒 C，而且很喜欢 Ruby。

如果只是为了用 API，你并不需要知道太多高级 C 语言里面的概念；大多的复杂性都被封装到方法和宏里面了。但是 API 列表实在太 **长＊＊，大部分又 **没有文档**。所以当你开始用的时候，你就会发现你需要深入到 Ruby 源代码来了解一些方法或宏的行为。Ruby 源代码用了不少复杂的 C 技巧，你至少要能够读懂这个。

在下一节，我将要说“所有你能用 Ruby 做的东西，你都能用 [the] C API 来做”。这是真的，但是用 C 并不直观而已。如果你对 Ruby 的设计和实践并没有强烈的直觉，那么你将会很难找到你想要的 API 方法了。

## 结合的两种方法 ##

Ruby 的官方解释器就是用 C 来写的。意思就是你能用 Ruby 做的东西，你都通过调用 Ruby 的 C API 来做。为什么有人想这么做呢？以下就是两个好理由：

1. 你正在用 C 或 C++ 来写应用，但你又希望你的某些代码能够具有 Ruby 的动态性和灵活性。那你可以在你的应用里面运行 Ruby 解释器，然后用 C API 来获取 Ruby 代码的运行结果。
2. 你正在用 Ruby 来写应用，但你又希望你的某些代码可以有 C（或者用 C 来写的库）的速度跟能力。那么你就可以通过用 API 来编译 C 代码成 Ruby 能 `require` 的库来把 C 代码暴露给你的 Ruby 代码。

根据你的目的不同，你也要用不同的方法来组织你的 C 代码。如果你希望嵌入 Ruby 解释器到 C，阅读 [Running Ruby in C](../embed)。如果你想 `require` 一个编译的 C 语言库，阅读 [Running C in Ruby](../extend)。在你读完那两篇文章后，请再回到这里来了解 API。

## Eval ##

最快能在 C 里面运行 Ruby 代码的方法就是 `eval` it

{% highlight c %}
{% include c/eval.h %}
{% endhighlight %}

如果你找不到想要的 API 方法[^wrap]，这不失为一个好的替代方案。`rb_eval_string_protect()` 会返回 Ruby 代码的结果，并且会在异常抛出时把 `state` 设为非零值。 `VALUE` 是所有 Ruby objects 的 C 的数据类型，这会在下一节解释。

如果 `state` 是非零值，`result` 会是代表 `nil` 的 `VALUE`，你应该自己来处理例外。你也可以调用不需要传入 `state` 参数的 `rb_eval_string()` 来正常地抛出异常。通过 [Exceptions](#exceptions) 来了解怎么处理这些情况。

与 Ruby 的 `eval` 不同的是，这两个方法是在一个隔离的 binding 里面执行那些字符串 &ndash; 就像你 `require` 某些文件。所以字符串里面的本地变量相对其它地方是不可见的，相反亦然。

就像在 Ruby 里面使用 `eval`，使用这些方法并不是一种好的实践。这些方法是很没效率的，因为需要触发 parser，这样多多少少与用 C 来写代码的目的相背离。如果你只是想调用某些 Ruby 方法，我们可以有更好的方法来做这个 [later on](#send)。

## VALUE ##

在我们继续下去之前，我们需要先理解 `VALUE`。为了避免你在 VM 里面胡来，API 并不允许你直接修改 Ruby 的 objects[^intern]。作为替代，你需要在 C 代码用 _pointers_ 来保存或传递 Ruby objects（就像 Ruby 变量也是保存指向 objects 的 pointers）。你可以通过把这些 pointers 传给不同的 API 方法和宏来安全地存取或修改 Ruby objects。`VALUE` 就是 API
为这些 pointers 所定义的 C 类型。

也许你最经常要问的是：“`VALUE` 是不是你想要的类型？”。以下是两个用来检查类型的宏，它们都需要一个与 Ruby 类相关的参数：[`T_` constant](../readme#data-types) ，例如 `T_STRING`，`T_ARRAY` 等等。

{% highlight c %}
{% include c/checktype.h %}
{% endhighlight %}

这些测试对于子类也同样适用：你可以用 `T_ARRAY` 来测试 `Array` 的某个子类；也可以用 `T_OBJECT`[^tdata] 来测试 `Object` 的某个子类。这也是说，这些测试并不像 `is_a?` 那样；尽管在 Ruby 下所有东西都是 Object，用 `T_OBJECT` 来测试的话，只有在没有更合适的常量来测试的时候才会返回 true。

对于内置的类来说，有一些特殊的宏可以用，它们会比之前的更有效率：

{% highlight c %}
{% include c/check_p.h %}
{% endhighlight %}

如果你希望处理一个可以是多种类型的 `VALUE`，那么之前的宏就略显笨拙了。这种情况下，你可以用 `TYPE()` 来获取那个 `T_` 常量，然后用 `switch` 来处理它：

{% highlight c %}
{% include c/type.h %}
{% endhighlight %}

### Constants ###

大多 Ruby 内置的常量都已经定义了全局 `VALUE`，所以你并不需要调用 API 来获取它们。Modules 会用 `rb_m` 作为前缀，例如 `rb_mKernel`；classes 会用 `rb_c` 作为前缀，例如 `rb_cObject`；`Exception` 的子类会用 `rb_e` 作为前缀，例如 `rb_eRuntimeError`；标准 IO 流会用 `rb_` 来作为前缀，例如 `rb_stderr`。`nil`，`false` 和 `true` 会用 `Q` 来作为前缀，例如 `Qnil`。[^undef]为了方便，`Qfalse` 也是 C 里面的 false（`0`）。

### Translation ###

一些 Ruby 类跟 C 对应的类型类似。这些类会是你用来在 C 和 Ruby 之间转换数据的主要途径。

#### Fixnum ####

Ruby 的 `Fixnum` 与 C 的 `long` 相关。`FIX2LONG()` 宏能给你一个 `Fixnum` 对应的 `long`。对于更小的 C 类型，你可以用 `FIX2UINT()`，`FIX2INT()` 和 `FIX2SHORT()`，不过如果转换失败，则会抛出一个 `RangeError`。

反过来看，`LONG2FIX()` 可以给 `long` 和每个更小的整形 C 类型。

#### Bignum ####

Ruby 的 `Bignum` 是给所有大于 `Fixnum` 的数字使用的。如果你需要用到 `long long` 的话，可以用 `Bignum`，例如，`rb_big2ll()` 和 `rb_big2ull()` 可以将一个 `Bignum` 对应转成 `long long` 和 `unsigned long long` （也有可能抛出 `RangeError` 异常）。

相反的转换可以看 [Numeric](#numeric)

#### Float ####

Ruby 的 `Float` 对应于 C 的 `double`。`RFLOAT_VALUE()` 宏将 `Float` 转 成 `double`。

相反的转换可以看 [Numeric](#numeric)

#### Numeric ####

以下是一系列可以动态转换的 "NUM" 宏。它们可以将 C 类型转换成合适的 `Numeric` 子类。

* `INT2NUM()` for `int`
* `UINT2NUM()` for `unsigned int`
* `LONG2NUM()` for `long`
* `ULONG2NUM()` for `unsigned long`
* `LL2NUM()` for `long long`
* `ULL2NUM()` for `unsigned long long`
* `DBL2NUM()` for `double`

也有一些反过来将所有 `Numeric` 转换成想要的 C 类型的宏。如果数值并不能转换，它们就会抛出 `RangeError`；如果并不能转成 Numeric，那它们就会抛出 `TypeError`（所以你可以安全地传非 `Numeric` 对象过去）。

* `NUM2CHR()` for `char` (works for `unsigned char` too)
* `NUM2SHORT()` for `short`
* `NUM2USHORT()` for `unsigned short`
* `NUM2INT()` for `int`
* `NUM2UINT()` for `unsigned int`
* `NUM2LONG()` for `long`
* `NUM2ULONG()` for `unsigned long`
* `NUM2LL()` for `long long`
* `NUM2ULL()` for `unsigned long long`
* `NUM2DBL()` for `double`

它们中的某个陷阱是如果你传一个负值给那些目的转换成无符号类型的宏，它们会抛出异常（this [isn't a bug][bug]）。`NUM2CHR()`也会有一些奇怪行为：它只有在一个值对于 _int_ 类型太大的时候才会抛出 `RangeError` 异常；当你传进一个字符串的时候，它会返回该字符串的第一个字符的数值，而不是抛出一个 `TypeError`。

如果你确定转换是安全的，你应该用前几节的宏来跳过范围检查。

[bug]: https://bugs.ruby-lang.org/issues/9089

#### String ####

Ruby 的 `String` 某种程度上对应 C 的 `char*`。最简单的宏就是 `StringValueCStr()` ，它可以将一个 `String` 转成一个终结符为 null 的 `char*`。这个宏的问题是，Ruby 的 `String` 有可能包含 null，这样的话，`StringValueCStr()` 会抛出一个 `ArgumentError` 的异常！这样的话，你可以用宏 `StringValuePtr()` 和宏 `RSTRING_LEN()` 来得到一个 `char*` 和字符串的 `long` 型长度值。
Ruby's `String` kinda corresponds to C's `char*`. The simplest macro is
`StringValueCStr()` which returns a null-terminated `char*` for a `String`. The
problem here is that a Ruby `String` _might contain nulls_ - in which case
`StringValueCStr()` will raise an `ArgumentError`! Instead you can use the
macros `StringValuePtr()` and `RSTRING_LEN()` to get a (possibly unterminated)
`char*` and the string's length as a `long`.

相反，如果你有一个终结符为 null 的 `char*`，你可以用 `rb_str_new_cstr()` 宏创建一个 Ruby `String`。如果你希望你的 `String` 包含 nulls，也可以用以一个 `char*` 和字符串长度值作为参数的 `rb_str_new()`宏。这些字符串的编码都会是 `ASCII-8BIT`，这经常那个不是 Ruby 想要的。这时候你可以传一个字符串 `VALUE` 到 `rb_str_export_locale()` 来得到一个以你的 local 来编码的字符串 `VALUE`[^wchar]。

如果你想构造更复杂的字符串，你可以用类 `printf` 方法 -- `rb_sprintf()`。它除了接受所有通用的转换格式符，也接受 API 定义的格式符 `PRIsVALUE`。`PRIsVALUE` 通过调用 `to_s` 方法来支持 `VAlUE` 参数。You can substitute the result of `inspect` instead by adding the `+` flag.

{% highlight c %}
{% include c/printf.h %}
{% endhighlight %}

`PRIsVALUE` 应该可以用在 API 的所有类`printf`方法。`PRIsVALUE` 通过劫持了 `i` 转换格式符来实现，所以如果你需要打印一个 `int`，你应该用 `d` 来避免 Ruby 认为它是一个 `VALUE`。

#### Symbol ####

API 定义了 C 的类型 `ID` 来对应 Ruby 的 `Symbol`。就像 Ruby 传 `Symbol`s 来作为方法名或变量名，许多 API 调用也需要用 `ID` 来表示的方法名，或变量名。你可以用 `SYM2ID()` 和 `ID2SYM()` 来在 `Symbol` 和 `ID` 之间转换。相对 `Symbol` 而言，你可能更希望跟 `char*` 类型的 C 字符串进行转换。你可以用 `rb_intern()` 将 `char*` 转换成 `ID`，相反操作可以用 `rb_id2name()`。
The API defines a C type `ID` which corresponds to Ruby's `Symbol`. Just like
how Ruby passes around `Symbol`s as method or variable names, many API calls
that need a method or variable name use an `ID`. To convert between a `Symbol`
and an `ID` use the `SYM2ID()` and `ID2SYM()` macros. Instead of a `Symbol` you
may want to convert to/from a `char*` C string. To get an `ID` from a `char*`
use `rb_intern()` and for the reverse use `rb_id2name()`.

因为很多 API 方法需要一个 `ID` 来调用，但是大多数情况下你没有合适的 `ID`。API 也定义了大量的以 `char*` 为参数，但是会在内部执行 `rb_intern()` 的方法。因为这些方法更加可读，同时调用 `rb_intern()` 的损失是可以忽略不计的，所以我会更倾向于用这些方法。如果你发现你经常用一个特定的 C 字符串，你可以将它的 `ID` 保存起来，然后用 `ID` 来调用方法，这样的话，你可以获得一些效率上面的好处（尽管你需要在 Ruby 头文件里面查找这些）。

## Send ##

这一节包含一些直接调用 Ruby 方法的 API 方法。你应该尽可能地用这些方法，而不是 `rb_eval_string()` 之类的方法。这些方法会更快一些，因为它们跳过了语法分析和编译时检查。

send 一个对象的方法的最简单途径大概就类似下面的：

{% highlight c %}
{% include c/funcall.h %}
{% endhighlight %}

与其相对应的 Ruby 代码如下：

{% highlight ruby %}
{% include c/funcall.rb %}
{% endhighlight %}

第一个参数是接收者。下一个参数是代表方法名的 [`ID`](#symbol) 。第三个参数是方法参数的数量，这个参数是存在是因为 `rb_funcall()` 是一个变参的方法。剩下的才是真正的方法参数。

另外，你也可以用 `rb_funcallv()` 方法，它的第四个参数是一个指向 C 参数数组的 `VALUE*`。这个方法有一个像 Ruyb 里面的 `public_send` 的变形 -- `rb_funcallv_public()` 。

### Passing Blocks ###

想传一个作为 block 的 `Proc` 给一个方法是很简单的。该方法就像 `rb_funcallv()`，只是最后多了一个 proc 参数。

{% highlight c %}
{% include c/proc.h %}
{% endhighlight %}

如果你没有代表 block 的 proc，你需要定义一个 C 方法来代表 block。以下有一个需要两个额外参数的 `rb_funcallv()` 的变形：

{% highlight c %}
{% include c/block.h %}
{% endhighlight %}

`rb_block_call()` 的最后一个参数可以用来在 block 的域之外传进 values，但是我们在例子中没有用到（所以我们用了 `nil`）。我同时建议除非你确定只有一个 value 被 yielded，否则不要使用第一个参数。因为你总能用 `argv` 来得到所有的参数，为什么不安全一点呢？[^break]

## Builtins ##

Ruby 的许多内置类都有相应的 API 方法来对应它们的常用方法。使用它们可以避免使用 `rb_funcall()` 时的冗长，也可以提供运行时检查。它们实在太多了，我建议你可以查看头文件 `ruby/intern.h`。
`ruby/intern.h`.

这些方法一般都会像 `rb_(class)_(method)` 那样命名，并且至少有一个 `VALUE` 参数（接收者）。例如，`rb_ary_pop()` 对应 `Array#pop`，`rb_obj_dup()` 对应 `Object#dup`，等等。

## Require ##

API 也可以从脚本里面加载 Ruby 代码。以下就是 `require` 的等价用法：

{% highlight c %}
{% include c/require.h %}
{% endhighlight %}

跟 `require` 一样，加载过程可能会抛出异常。可以阅读 [next section](#exceptions) 来了解怎么处理异常。

如果你希望多次加载一个脚本，API也提供了与 `load` 对应的方法：

{% highlight c %}
{% include c/load.h %}
{% endhighlight %}

就像 [`load` in Ruby][rbload]，这些方法也可以把加载的代码包裹到一个匿名的 module 来保护全局命名空间。只需要在第二个参数里面传一个非零值就可以了。

[rbload]: http://www.ruby-doc.org/core-1.8.6/Kernel.html#method-i-load

## Exceptions ##

### Raise ###

抛出异常，可以像下面那样调用：

{% highlight c %}
{% include c/raise.h %}
{% endhighlight %}

第一个参数是异常类，第二个参数是错误消息 &ndash; 就像 Ruby 中 `raise`。最大的不同就是这里的错误消息是一个格式化字符串 [just like in `rb_sprintf()`](#string)，主要为了方便构造消息。

### Rescue ###

API 提供了几种方法去捕获异常。它们都要求你把你要保护的代码放到一个参数是一个 `VALUE`，返回也是一个 `VALUE` 的方法里面。

{% highlight c %}
{% include c/danger.h %}
{% endhighlight %}

除非你的要保护的代码就是这样的，否则你需要创建一个这种格式的包装器来执行需要的代码。存取捕获到的异常也完全跟它被捕获的方法独立：

{% highlight c %}
{% include c/handle.h %}
{% endhighlight %}

`rb_errinfo()` 本质上返回对应 Ruby 的 `$!` 的 `VALUE`（如果没有异常发生，那么它将会是 `Qnil`）。与 Ruby 不同的是，你需要在读完异常之后手动去清理它[^clear]。不然的话，接下来的 API 调用可能会读到旧的值，然后认为异常发生了。

接下来我们需要了解一下用于捕获的几个方法；哪一个你都可以用，但我认为你需要根据你的用例 [use-case](#the-two-paths) 来决定才是正确的选择。

#### rb_rescue2 ####

如果你只是编译一个库给 Ruby 加载，那问题就很简单。从 API 抛出的异常都可以在你的 Ruby 代码里面被捕获。如果你希望在 API 里面捕获异常，你可以用与 Ruby 的 `rescue` 相似的 `rb_rescue2()` 。

{% highlight c %}
{% include c/rescue2.h %}
{% endhighlight %}

最开头的两个参数就是你要保护的方法和它的参数，接下来的两个参数就是异常被抛出时调用的方法跟他的参数。`rb_rescue2()` 是一个变参方法，所以接着的参数就是你希望捕获的异常类列表。最后一个参数需要为0，以此表示异常类列表的结束。就像 Ruby 的 `rescue`，不在列表中的异常是不会被捕获的。如果你想捕获 `StandardError`（就像 Ruby 中的空白 `rescue`），你可以用 `rb_rescue()`，它只接受 `rb_rescue2()` 的前四个参数来调用。

API 并不支持像 Ruby 那样可以根据不同的异常类执行不同的代码。你需要捕获所有你想要的异常类，然后用 switch 来分别处理。

API 也不直接提供类似　Ruby 的 `else` 的功能，即在没有异常情况下执行对应的代码。实现这个的其中一个方法就是利用 `rb_rescue2()` 的返回值。如果没有异常发生，它返回第一个方法(dangerouse function)的返回值，否则就返回第二个方法(rescue function) 的返回值。通过这两种返回值，假设是 `Qtrue` 和 `Qfalse`，你可以知道你是处于哪种情况。

#### rb_protect ####

如果你是在 C 里面嵌入 Ruby 解释器，那么你在调用那些可能抛出异常的 API 方法时就需要特别小心：**一个不被捕获的异常将会 segfault 你的 VM，从而杀死你的程序**。你可以用 `rb_eException` 来调用 `rb_rescue2()`，不过我们有另一种方法俩捕获所有的异常：

{% highlight c %}
{% include c/protect.h %}
{% endhighlight %}

就像 `rb_rescue2()`，最开头的两个参数就是你需要保护的方法。然而，就像 `rb_eval_string_protect()`，如果异常发生了，它会返回 `Qnil`，然后把 `state` 设置为一个非零值。如果你想重抛出这个异常，你可以把 `state` 传给 `rb_jump_tag()`（这一点对于其它 `*_protect()` 方法也同样有效）。

### Ensure ###

`rb_ensure()` 与 `rb_rescue()` 类似，除了它并不处理异常，而且它的第二个方法总会在第一个方法执行完之后被执行。这听起来很简单，但却意味着如果你想要一个 跟 Ruby 的 `begin; rescue; ensure; end` 一样的结构，你需要多一层的包装器：

{% highlight c %}
{% include c/ensure.h %}
{% endhighlight %}

就像 Ruby 的 `ensure`，`ensure_func()` 的返回值是不会被使用的。如果没有异常抛出，`rb_rescue()` 返回 `begin_func()` 的返回值，`begin_func()` 返回 `dangerous_func()` 的返回值。如果异常发生了，`rb_rescue()` 返回 `rescue_func()` 的返回值。

## Definitions, Declarations ##

到现在为止我们都是在 VM 里面创建跟修改对象，但是好像我们的 API 调用都没有跟 Ruby 代码有任何交互：用 `rb_str_new_cstr()` 创建的 `String` 默认只能用 C 来存取。

有几个方法来让它们对 Ruby 可见，不过它们都是用同样的原理：通过定义一些 Ruby 能访问的 name，例如，变量 name，方法 name，等等。不过有个注意的地方：不像 Ruby，**API 允许你命名非法的 name**。如果你定义一个叫 `foo` 的类或者一个 `bar` 的实例变量，Ruby 会抛出 `SyntaxError` 或者 `NameError`，但是 API 会直接创建。API 通过**不暴露那些 names 到 Ruby** 来解决这个问题。如果发现程序运行跟所想不一样，可以检查你选择的 name。

这节的大部分 API 方法跟 Ruby 的元编程方法相符。当你尝试用 API 来写代码的时候，想想你在只有 Ruby 元编程方法会怎么做是很有帮助的。例如，相比 ``class Foo; def bar; end; end`，多想想 `Foo = Class.new; Foo.define_method(:bar) {}`。

### Global Variables ###

处理全局变量最简单的方法是：

{% highlight c %}
{% include c/global.h %}
{% endhighlight %}

如果你需要经常存取 Ruby 的某个全局变量，你可以建立一个可以自动同步的 `VALUE`。

{% highlight c %}
{% include c/global2.h %}
{% endhighlight %}

`VALUE` 值应该在你在 Ruby 里面创建全局变量前被初始化，它在 C 里面也应该是全局的 &ndash; 你总不想在 Ruby 访问它的时候需要切换变量范围！对于 `rb_define_hooked_variable()` 的话，如果你只是想同步，你可以传 `NULL` 过去就可以了。或者你也可以用 `rb_define_virtual_variable()` 直接抛出 `global`，这种情况下，getter 跟 setter 方法都需要已定义。

如果你在 C 里面创建了一个不暴露给你 Ruby 的全局 `VALUE`。你需要提醒垃圾回收，免得它回收了这个 `VALUE`：

{% highlight c %}
{% include c/gc.h %}
{% endhighlight %}

### Class and Instance Variables ###

存取实例变量跟存取全局变量相类似，除了你需要传一个 object 来指明它的实例变量。

{% highlight c %}
{% include c/ivar.h %}
{% endhighlight %}

这里就不存在像全局变量那样可以自动同步实例变量的方法了。

对于类变量，方法改为 `rb_cv_get()` 和 `rb_cv_set()` 就可以了，当然第一个参数需要是一个类对象。

### Constants ####

常量定义也是差不多的，不过指明它属于的 module：

{% highlight c %}
{% include c/constant.h %}
{% endhighlight %}

你可以通过把变量设为 `Qundef` 来 undefine 一个常量。获取一个常量的 `VALUE` 的方法有些细微的差别。你需要依据你期望该常量在那个 module 下未被定义时的行为来选择用哪个方法。

{% highlight c %}
{% include c/const_get.h %}
{% endhighlight %}

所有这些 API 方法都可以用来获取私有常量。

### Modules and Classes ###

定义 modules 很简单。

{% highlight c %}
{% include c/module.h %}
{% endhighlight %}

类也是这么去定义，不过需要指明父类。

{% highlight c %}
{% include c/class.h %}
{% endhighlight %}

### Methods ###

现在开始变得有趣了。API 有很多种调用来定义方法，不过你要在用它们之前定义一个 C 方法。这个 C 方法需要返回一个 `VAlUE` ，也需要传进一个作为接收者的 `VALUE` 参数。下面有三种方法来定义它的参数：

{% highlight c %}
{% include c/methodc.h %}
{% endhighlight %}

所以事实上 API 只让你定义两类方法：一类接收固定数量的参数，另一类把所有参数放到一个数组里面。那么 Ruby 那些参数特性哪去了？可选参数，选项哈希，block，还有它们的组合都去哪了？

#### Parsing Arguments ####

如果你想要一个参数数量可变的方法，你可以在你的方法里面写那些处理，使得它表现得像 Ruby 的方法那样。谢天谢地，API 提供了做这个的方法。为了支持这个，你应该用那种 C 数组的方法定义，这样你才可以传 `argc` 和 `argv` 过去：

{% highlight c %}
{% include c/scan.h %}
{% endhighlight %}

`fmt` 是一个可以描述 Ruby 的方法参数的带格式的字符串。`fmt` 最多只能有六个字符，每个字符描述你参数的不同部分。这六个部分和它们的意义如下：

1. 开头的强制的参数数量：数字
2. 可选参数数量：数字
3. 变长参数（a splatted argument）: `*`
4. 尾部强制参数数量：数字
5. 关键字参数：`:`
6. 代码块参数：`&`

每部分都是可选的，所以你可以不填那些你不需要的字符。不过有点你需要注意的是这个格式化字符串是贪婪的：`1*` 描述了一个声明一个强制参数和变长参数的方法。如果你想要声明一个有一个可选参数和一个变长参数的方法，你需要声明为 `01*`。在格式化字符串之后，你需要传 `VALUE*` 给每个 Ruby 参数。需要传的指针数量需要等于这六个部分的总数，虽然你可以传一个 `NULL` 过去。举个例子，对于格式化字符串 `21*&`，你需要传5个 `VALUE*` 过去（2 个强制参数，一个可选参数，一个变长参数，一个代码块）。

`rb_scan_args()` 会用你传过去的 `VALUE*` 来解析 `argv`，如果你传过来的参数数量有误，则会抛出一个异常。

{% highlight c %}
{% include c/methodex.h %}
{% endhighlight %}

你也可以利用 `rb_scan_args()` 的返回值来判断方法的调用。它会返回在 Ruby 传过来的参数数量。

#### Handling Blocks ####

以下是判断一个方法是否被传进一个代码块的两种方法：

{% highlight c %}
{% include c/checkblock.h %}
{% endhighlight %}

有两种方法将 block 转为 proc。如果你用 `rb_scan_args()` 的话，在你的格式化字符串包含 `&` 就可以了。如果你不是用 `rb_scan_args()`，下面是一个类似于 `Proc.new` 的 API 调用可以将一个方法的 block 转为 proc：

    VALUE block;
    block = rb_block_proc();

如果你并不希望获取 block，以下有几个方法可以 yield 这个 block：

{% highlight c %}
{% include c/yield.h %}
{% endhighlight %}

API 调用里面也有个类似 `rb_yield_values()` 的 `rb_yield_values2()` 方法，不过它的第二个参数是 `VALUE*`[^yield]。

#### Super ####

你可能想在你的方法里面调用 `super`。

{% highlight c %}
{% include c/super.h %}
{% endhighlight %}

如果你不传参数的话，`rb_call_super()` 并不能像 Ruby 那样会隐含地将方法参数传给 super。你需要明确传进正确的 `argc` 和 `argv`（它可以自动传如 `self`）。出于这个原因，如果你想用 `rb_call_super()` 的话，我建议用 C 数组特色的方法定义。

#### Definition ####

构建 C 方法是最困难的那部分，不过在 Ruby 内定义方法就变得简单了。每个用来创建方法的 API 调用都至少需要方法名（`char*`），指向你 C 方法的一个指针，和一个描述参数的 `argc`。`argc` 需要满足：

1. 如果参数数量固定的话，就是参数的数量（不包括接收者）
2. 对于在 C 数组的变长参数，用 `-1`
3. 对于在 Ruby 数组的变长参数，用 `-2`

下面的代码可以很好解释自己的用法：

{% highlight c %}
{% include c/methodr.h %}
{% endhighlight %}

下面是一个在 module 和它的 singleton 类里面定义方法的捷径。这个经常在 `Math` 里面用到，例如，方便你 `include Math` 来避免在每个方法前面输入 `Math.`

{% highlight c %}
{% include c/modulefunc.h %}
{% endhighlight %}

### Other Stuff ###

以下是一些用来定义 class/method 的 API 方法：

{% highlight c %}
{% include c/etc.h %}
{% endhighlight %}

## Data ##

现在你应该可以用 API 来创建和修改 Ruby 类，但是你应该怎样创建一个封装了 C 数据的 Ruby 类呢？如果你的数据可以被转成 `VALUE`，那么这很简单：转化并赋值给实例变量就可以了。不过如果你的数据并不能对应上 Ruby 呢（例如在 C 库里面定义的数据结构）？

API 允许你通过在类里面创建一个 `VALUE`，然后用它来保存一个在 Ruby object 里面指向 C 的数据 `void*` 的。然后不管什么时候你需要存取 C 的数据，你可以把这个指针拆出来，并用正确的类型来声明它。不过封装是在哪里发生的呢？让我们用一个问题来回答那个问题：当你在 Ruby 里面用 `new` 来创建一个对象到底发生了什么？基本是这样的：

{% highlight ruby %}
{% include c/new.rb %}
{% endhighlight %}

在调用实例方法 `initialize` 之前，`new` 先调用类方法 `allocate` 来真正地创建一个实例。如果你希望你的对象包装 C 的数据，那么这就是你需要定义的方法。下面的例子创建了一个包装了一个能在 `initialize` 设置一个 `int` 变量的 `Foo` 类：

{% highlight c %}
{% include c/wrap.h %}
{% endhighlight %}

大多数情况，你可能是包装些更复杂的东西（例如一个 `struct`），不过原理是一样的。在分配到 C 的数据内存后，我们用 `Data_Wrap_Struct()` 宏来用 `VALUE` 来包装该指针。这个宏的第一个参数是保存 `VALUE` 的类，在这里的话，就是接收者，因为我们就在一个类方法。第二个参数是用于 Ruby 垃圾回收的，我们会在以后讲到的，不过只要你的 C 的数据不指向任何 Ruby 对象，你就不需要它，可以传 `NULL` 过去。第三个参数是当实例被毁灭时给垃圾回收调用的方法。最后一个就是这个指针。用 [`TYPE()` macro](#value) 来查看包装 C 数据的 `VALUE` 会返回 `T_DATA`。

`Data_Get_Struct()` 就更简单了：它需要传进要拆包的对象，数据的类型和指向数据的指针。

这种分配内存和初始化与 [RAII](raii) 一点也不沾边，所以如果你用 C++ 的话，你可以想在包装数据的时候用 [placement new][place]。如果你在分开分配内存跟初始化遇到困难，你可以仅仅用一个 `struct` 来包装你的数据，然后在 `initialize` 时候做真正的分配内存。

[raii]: http://wikipedia.org/wiki/Resource_Acquisition_Is_Initialization
[place]: http://en.cppreference.com/w/cpp/language/new#Allocation

在一些简单的情况下（像之前的例子）你可以写得更简短些。如果释放你的数据只是调用 `free()`，你可以传 `RUBY_DEFAULT_FREE` 过去，Ruby 可以为你释放内存（千万不要用 `NULL`，除非你喜欢内存泄漏）。相似地，如果只是调用 `malloc()` 来分配内存，`Data_Make_Struct()` 可以帮你分配内存并包装它。我们可以重写上面的分配内存方法：

{% highlight c %}
{% include c/makestruct.h %}
{% endhighlight %}

### Marking ###

我们传给包装宏里的 `NULL` 参数就是指向你的对象的 "mark function" 的指针。这个命名的原因就是垃圾回收的 "mark and sweep" 算法。这个算法的思想就是当垃圾回收机制需要释放内存的时候，它会执行两个过程：第一个（mark）迭代所有引用的 Ruby 对象，然后标记它是活跃；然后第二个（sweep）迭代所有分配了内存的 Ruby 对象，如果它没有被标记为活跃的则释放掉。

这也跟包装 C 的数据有联系，因为你可能包装了一个包含了 Ruby `VALUE` 的 C `struct` &ndash; 这是垃圾回收有职责回收的。由于垃圾回收器只能察觉到被 Ruby 访问的 `VALUE`（不是被 C 指针指向的），它并不能标记这个 `VALUE` 是活跃的。这样的话，只要垃圾回收器需要释放内存，你的 C 数据就变成指向一个不存在的 Ruby 对象。

下面的例子里，我们包装一个包含一个 `VALUE` 的 C `struct`。这个标记函数跟释放函数一样的函数签名，不过它做的是标记 `struct` 里面的 `VALUE`：

{% highlight c %}
{% include c/mark.h %}
{% endhighlight %}

如果你的 `struct` 包含一个指向包含 `VALUE` 的 C 数组的指针，你可以用 `rb_gc_mark_locations()`，它需要传进两个参数：指向数组开头跟结尾的指针（结尾等于开头的指针加上数组的长度）。[^maybe]

## Threading ##

### Ruby in C Threads ###

如果你需要创建很多 API 调用并在 C 里面运行很多 Ruby 代码，你可能会想，“我正在用 API 来运行这些缓慢的 Ruby 方法。我是不是可以把它放到线程里面来让我的代码快点呢？” 这是个合理的想法，不过当你实现它的时候，你要记住 **Ruby VM 不都是线程安全的**。理想状态下，所有 API 代码需要在一个线程里面运行。如果不是，你需要用锁机制来包装所有 API 调用，以此确定你不会同时有多个线程跟 API 交互。

如果你只是想用 API 来创建一个 Ruby `Thread`（并不在意 GVL，下节会讨论），下面是实现这个的简单方法：

{% highlight c %}
{% include c/thread.h %}
{% endhighlight %}

其它 `Thread` 相关方法在 `ruby/intern.h` 里面（其它的都会有 `rb_funcall()`）。

### C in Ruby Threads ###

另一方面，如果你想用 API 暴露 C 代码给 Ruby（例如你正在写一个 extension 来包装一个 C 的库），你需要花点时间来了解一下这个名字叫全局 VM 锁（GVL）的讨厌玩意。因为大部分的 API 都不是线程安全的，GVL 锁住几乎所有的 Ruby 代码来让你每次只运行一个线程。这就是为什么你经常给你听到别人说线程并不能实现并行。

Ruby VM 也会在你给 Ruby 暴露的 C 代码上面运用 GVL。这就是为什么别人在用你的 C 代码时你可以不用担心这个。这样的缺点就是如果你的 C 代码需要比较长的时间来运行，你用 `Thread` 来运行它也不会有任何性能提升，因为 **它会阻塞别的线程**。不过只有你需要保护你的 API 调用时才需要 GVL。如果你有些 C 代码是不需要用到 API 的，你可以在你用线程来运行代码前让 VM 去释放 GVL，然后你完成的时候才去再获取它，这样就可以达到并行的目的。锁和解锁 GVL 会有性能损失，所以只有在你确定由于线程阻塞导致严重的问题的时候才这么做。

下面的代码在 Ruby 开发者看来有点奇妙，你需要引入另一个头文件来实现这个。首先我们看一下释放 GVL 的简单代码：

{% highlight c %}
{% include c/gvl2.h %}
{% endhighlight %}

由于这个不在 GVL 下运行的方法用 `void*` 来获取跟返回数据，你可能也希望定义一个 `struct` 来传递数据。

如果你像上面那样解锁 GVL，你会发现你的代码是并行了，但是却不能被中断（用 signal，`Thread.kill` 等等）！为了允许这个，你需要在后面两个参数传进解锁的方法。

{% highlight c %}
{% include c/gvl.h %}
{% endhighlight %}

这个解锁的方法会在中断发生的时候执行。为了让代码能正常运行，你可能需要给它们传一个在两者之间通信的指针。被中断的方法需要在提前返回时执行必要的清理。

如果方法不需要运行执行特别的清理，你可以用内置的解锁方法 `RUBY_UBF_IO`[^ubf]`（它会忽略解锁参数）。它只是转发中断信号给正在跑的线程。[^int]

如果你在释放 GVL 之后发现你需要在你的解锁的方法执行 API 调用，以下是用来暂时获取 GVL 的方法：

{% highlight c %}
{% include c/with_gvl.h %}
{% endhighlight %}

## See Also ##

### README.EXT ###

[README.EXT](../readme) 是 Ruby 官方的 API 文档。它是 Ruby 源代码里面的一个文本文件，不过我格式化成 HTML 了。它虽然有些污点和不好的建议（在我的观点看来），但在某些主题上它又是很详尽的。在很多情况下，是因为我故意跳过某些我觉得没啥用或者在其它地方已经讲得很清楚的部分。

### Headers ###

我认为有些方便的资源就是 Ruby 头文件它们。全部的 API （即是你通过 `ruby.h` 引入的所有东西）包含了上千的方法，宏，常量和全局变量 &ndash; 它们中的大多数从未被写进文档。然后它们的大多数都命名地很合理，你应该可以从头文件看出它们是干什么用的。你需要的大多数应该都在 `ruby/ruby.h` 和 `ruby/intern.h` 里面。前者包含了所有 VM 和元编程的方法，后者包含了所有跟 Ruby 内置类相关的方法。

也有些头文件并没有在 `ruby.h` 里面被引入，你可以引入来获得另外的 API 功能。也许有天我会写另一节来覆盖它们：

* `ruby/debug.h` (experimental) functions for profiling and tracing code
* `ruby/encoding.h` functions for working with string encodings
* `ruby/io.h` additional functions for Ruby's IO class
* `ruby/re.h` additional functions for Ruby's Regexp class
* `ruby/thread.h` functions for working with the [GVL](#c-in-ruby-threads)
* `ruby/version.h` functions for version introspection. Do not use this as
  feature-detection code!
* `ruby/vm.h` (experimental) functions for VM control

### Source ###

如果你发现没有在头文件解释到的方法，你应该到 Ruby 源代码里面找找看。

    $ git clone https://github.com/ruby/ruby.git

当浏览源代码时，记住保持那些头文件在手：那里有很多很有用的方法看起来应该是在 API 里面，但事实上不是。大多数情况，它们都会被包装在别的 API 方法下。

### Examples ###

Head over to the [Examples](../examples) page for short, compilable examples of
the API in action.

### Contribute ###

Now that you've finished reading my guide, did you notice something significant
that I left out? Did I make some stupid mistake? Check out the [source][gh] for
this site on Github and you can report issues, submit pull requests, and
download all of the code examples.

[gh]: https://github.com/silverhammermba/emberb

## Footnotes ##

[^intern]: Okay, that's a blatant lie. The API _totally_ lets you mess around
           with the internal data structures of objects (look for things with
           names starting with capital R). But it's generally not a good idea
           and not necessary.

[^undef]: There's also `Qundef` representing an undefined value, but
          this has no Ruby equivalent and is [rarely](#handling-blocks)
          [used](#constants-1). In fact, outside of those rare occassions,
          `Qundef` can segfault the VM if Ruby was expecting a normal `VALUE`.

[^wrap]: There's also `rb_eval_string_wrap()` which _should_ be useful, but is
         actually the same as `rb_eval_string_protect()` due to a [bug][bug2].

[^chr]: There is a `CHR2FIX()` macro, but in my tests this sometimes gave
        unexpected results. `LONG2FIX()` should work.

[^wchar]: I don't know what the best way is to handle `wchar_t`. In my tests I had
          some success just treating them as `char`s, but I think that may have
          been a happy accident, and could certainly fail on different platforms.

[^clear]: The documentation [states](../readme#control-structure) that "You have to
          clear the error info [when] ignoring the caught exception". But I can't
          find any documentation of when it would be cleared for you &ndash; it seems
          like you _always_ have to clear it.

[^yield]: And there's `rb_yield_block()` which takes two unused arguments and is
          never called by anything in Ruby. Odd.

[^break]: The documentation [mentions](../readme#control-structure)
          `rb_iter_break()` and `rb_iter_break_value()` for breaking out of a
          block, but can't you just return early? I can't think of a use-case
          for these.

[^int]: There is also the function `rb_thread_call_without_gvl2()`. The
        documentation in `thread.c` says that if "[it] detects interrupt, it
        returns immediately." but I'm not sure what this means. If the
        unblocking function doesn't kill the thread, it still waits for the
        thread to finish on its own before returning.

[^ubf]: You can also use `RUBY_UBF_PROCESS`, but this seems to be a leftover
        from deprecated code and has the exact same effect.

[^maybe]: There's also the enigmatically named `rb_gc_mark_maybe()`, but I'm not
          sure when it is needed.

[^tdata]: Or use `T_DATA` if the object [wraps a C pointer](#data).

[bug2]: https://bugs.ruby-lang.org/issues/10466
