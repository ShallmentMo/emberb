---
layout: chapter
title: Running C in Ruby
---

## 编译 ##

编译作为 Ruby extension 来加载的 C 代码需要一些编译器技巧。使用 Ruby 的 [`mkmf` stdlib][mkmf] 可以帮助我们生成合适的 makefile。

### 准备 ###

首先在你的 C 代码目录下创建 `extconf.rb` 文件：

{% highlight ruby %}
{% include extend/ext/extconf.rb %}
{% endhighlight %}

以上代码的执行类似标准 UNIX [`configure` script][conf] 里面的 actions 例如:

* 检查当前平台的特性
* 检查需要的库和方法是否有效
* 检查用于构建的程序是否有效

[conf]: http://en.wikipedia.org/wiki/Configure_script

`mkmf` 已经提供了通用的 actions（but you have all of
Ruby at your disposal if you need it）。举个例子，一个使用 SDL2 的 extension 需要知道 `int` 的位长，可以这么调用：

{% highlight ruby %}
{% include extend/ext/exex.rb %}
{% endhighlight %}

`create_header` 根据你之前调用的 `mkmf` 方法结果来创建包含预处理定义 `extconf.h` 头文件。用刚才的例子来举例的话，`extconf.h` 大概是这样的

{% highlight c %}
{% include extend/ext/exh.h %}
{% endhighlight %}

你应该在你的 C 代码里面包含此头文件，这样你的代码就可以适用于不同的平台。值得注意的地方是，如果 `mkmf` 方法返回一个暗示你的构建过程会失败的值，你可以并应该终止 `extconf.rb` 脚本。举个例子，如果 SDL2 是你的 extension 的必要条件，那么当 `have_library('SDL2')` 返回 `false` 的时候，你应该退出编译，然后提示错误。这样比依然生成 Makefile，留给用户迷惑的编译器错误好很多。

`create_makefile` 明显是用于创建 Makefile 的，但是我们应该留意它的参数：它定义了你的 C 代码的入口，编译库的名字，还有用于 Ruby `require` 的参数！这个参数也应该是你的 extension 的名字。

你可以通过在 Ruby里面修改这些全局变量：`$CFLAGS`, `$CPPFLAGS`, and `$LDFLAGS`[^glob] 来修改生成的 Makefile 的对应变量。如果自动生成的目标文件不是你的 extension 需要的，你也可以用 `$objs` 这个全局变量来定义 Makefile 里面的 object files 列表。

`mkmf` 的方法和选项都可以在文档 [online][mkmf] 里面找到。除了用来生成 `extconf.h` 的方法之外，文档还有一系列的方法用于处理不同的源文件（handling different source file layouts），不同的文件依赖，等等。

[mkmf]: http://www.ruby-doc.org/stdlib/libdoc/mkmf/rdoc/MakeMakefile.html

### 执行 ###

剩下的就简单到不能再简单了

    $ ruby extconf.rb
    $ make

[^argv]当然现在不会发生什么，因为没有用于编译的 C 代码。

## 初始化 ##

在你的 C 代码里面，你需要引入 `ruby.h` 来调用 API。除此之外，你只需要定义一个方法以便在 `require` 之后被 Ruby VM 调用。这个方法的方法名就是你在 `extconf.rb` 里面传给 `create_makefile` 的参数。我们在例子里面用的是 "foobar"，所以我们需要创建 `foobar.c`，它的代码如下：

{% highlight c %}
{% include extend/ext/foobar.c %}
{% endhighlight %}

### 文件名 ###

如果你的 extension 只有一个 C 文件，那么你应该像上面那样来命名你的文件。但是如果你的 extension 有多个 C 文件，那么不要以你的 extionsion 来命名你的 C 文件。因为 Makefile 会在链接阶段用你的 extension 名来生成 `.o` 文件，如果你有一个 `.c` 文件也是这个名字的话，就会产生冲突。

也请不用以 `conftest.c` 来命名任何文件，因为此文件可能会被 `mkmf` 写入。

## 完成 ##

现在 make 可以编译出一个可以用来在 Ruby 里面 `require` 的 `.so` （或者其它库)文件了。你可以在你的 `Init` 方法里面写 C 代码了，不过你可能希望了解更多关于 [C API](../c) 的内容来完成更多有趣的东西。

## Gem ##

等到你的 extension 可以很好地工作之后，你可能希望打包成一个 Ruby gem。rubygems.org 有关于创建 gems 的 [详细教程](rbg)，不过如果需要用到 C extensions 的话，你需要在 gem spec 里面加上以下关于 `extconf.rb` 的代码:

{% highlight ruby %}
{% include extend/foobar.gemspec %}
{% endhighlight %}

如果你的 gem 需要包含不同独立的 extensions，你可以在 `ext/` 下用不同的子目录来组织它们，然后在 gem spec 里面指明所有的 `extconf.rb`。

[rbg]: http://guides.rubygems.org/make-your-own-gem/

## Footnotes ##

[^glob]: I can only find these globals documented in README.EXT.

[^argv]: README.EXT [hints](../readme#generate-makefile) that `mkmf` parses certain
         command line flags e.g.  `--vendor`. But I can't find this documented
         anywhere.

[^rbg]: [http://guides.rubygems.org/gems-with-extensions/](http://guides.rubygems.org/gems-with-extensions/)
