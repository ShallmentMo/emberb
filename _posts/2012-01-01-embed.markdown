---
layout: chapter
title: Running Ruby in C
---

## 编译 ##

想在 C 里面嵌入 Ruby 代码需要引入一个头文件 `ruby.h`，这个头文件会引入平台专用（platform-specific）的 `ruby/config.h` 。你可能需要告诉你的编译器在哪里找到这些头文件。你也需要链接 Ruby 库。在作者的机器上面，最少的编译器选项是这样的

    -I/usr/include/ruby-2.1.0 -I/usr/include/ruby-2.1.0/x86_64-linux -lruby

然而，如果有可能，你可以用 `pkg-config` 来获取当前合适的选项：

    $ pkg-config --cflags --libs ruby-2.1

## Startup, Teardown ##

引入 Ruby 解释器到你的 C/C++ 程序里面是很简单的事。只需要引入头文件，然后用两个方法来包裹你的 API 调用。

{% highlight c %}
{% include embed/simple.c %}
{% endhighlight %}

如果 Ruby VM 在 `ruby_init()` 的时候失败了，它会打印出错误然后退出！如果你不希望这样，你可以调用 `ruby_setup()` ，它会在失败的时候返回一个非零值（这样的话，获取错误信息[^err]就变得不清晰）。

如果 `rb_cleanup()` 执行出错，它会返回一个非零值 &ndash; 否则它会返回你调用时传进来的参数。这样就提供了在 cleanup 失败时返回错误状态的途径。（
This allows a little shortcut for returning an error status if the cleanup fails）(像之类的例子显示那样).

在 cleanup 阶段，Ruby VM 可能会执行意料之外，但是报错的 Ruby 代码（例如，你传了一个 block 给 `at_exit`）。`ruby_cleanup()` 通过返回一个非零值，打印错误信息来处理这种情况。如果你有调用 `ruby_finalize()`，那么它们也会照常调用到。（留意 [Exceptions](../c#rescue) 来了解怎么处理它们）。

下面是另一个例子：

{% highlight c %}
{% include embed/advanced.c %}
{% endhighlight %}

## Tweaking the VM ##

上面就是简单的可以运行的 Ruby VM，不过你可能希望在运行 Ruby 代码之前设置更多的东西。例如，为错误信息设置 Ruby 脚本的名字（e.g. `$0`），可以像下面这么做：

{% highlight c %}
ruby_script("new name")
{% endhighlight %}

设置让 gems 用于 `require` 的 load path，可以像下面这么做：

{% highlight c %}
ruby_init_loadpath()
{% endhighlight %}

你也可以像在命令行执行 `ruby` 命令那样传选项过去给 VM。这样的话，设置 warning level 或者 verbose 模式[^opt] 就很方便了。

{% highlight c %}
{% include embed/options.c %}
{% endhighlight %}

传给 `ruby_options` 的参数就像主函数的 `argc` 和 `argv` 。就像 `ruby` 命令那样，VM 期望获得 Ruby 代码来运行。如果你没有传需要加载的脚本文件名，或者没有用 `-e` 来执行，它就会尝试从 `stdin` 读取 Ruby 代码。如果你只是想设置选项，而不想运行任何 Ruby 代码，你可以传空行 `"-e "` 过去。

`ruby_options()` 返回一个 "node" 代表编译的 Ruby 代码。在某些情况（例如语法错误），"node" 可能是无效的，那么你就不应该运行它。`ruby_executable_node()` 可以用于检测这个。如果 "node" 是有效的，你就可以通过调用 `ruby_exec_node` 来执行它。如果在编译或者运行时抛出一个异常，那么 `ruby_executable_node()` 跟 `ruby_exec_node()` 返回的状态值就会是一个非零值。你可以阅读 [the exception](../c#rescue) 来了解更多，或者传 `state` 给 `ruby_cleanup()` ，那样它可以打印合适的错误信息。

Ruby 现在还不支持其它方法来编译和执行代码[^load]。

## 完成 ##

现在你可以跟 Ruby 交互了！回去 [C API](../c)。

## Footnotes ##

[^err]: `ruby_init()` uses `error_print()` to get an error message, but this
        function isn't exposed to the API. Is this a normal exception?

[^opt]: In my tests I couldn't get flags like `-w` and `-v` to do anything. This
        could be related to `ruby_prog_init()`. And really it should be possible
        to do this without parsing command line options.

[^load]: It looks like the function `rb_load_file()` should do this, but I
         haven't had any luck getting it to work.
